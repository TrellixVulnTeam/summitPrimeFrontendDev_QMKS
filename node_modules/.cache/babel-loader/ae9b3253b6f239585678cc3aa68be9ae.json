{"ast":null,"code":"(function () {\n  /**\r\n   *\r\n   * Node:\r\n   * const csv2json = require('./csv2json.js');\r\n   * csv2json(csv, options)\r\n   *\r\n   * Browser:\r\n   * CSVJSON.csv2json(csv, options)\r\n   *\r\n   * Converts CSV to JSON. Returns an object. Use JSON.stringify to convert to a string.\r\n   *\r\n   * Available options:\r\n   *  - separator: Optional. Character which acts as separator. If omitted,\r\n   *               will attempt to detect comma (,), semi-colon (;) or tab (\\t).\r\n   *  - parseNumbers: Optional. Will attempt to convert a value to a number, if possible.\r\n   *  - parseJSON: Optional. Will attempt to convert a value to a valid JSON value if possible.\r\n   *               Detects numbers, null, false, true, [] and {}.\r\n   *  - transpose: Optional. Will pivot the table. Default is false.\r\n   *  - hash: Optional. Will use the first column as a key and return a hash instead of\r\n   *               an array of objects. Default is false.\r\n   *\r\n   * Copyright (c) 2014-2019 Martin Drapeau\r\n   *\r\n   */\n  var errorDetectingSeparator = \"We could not detect the separator.\",\n      errorNotWellFormed = \"CSV is not well formed\",\n      errorEmpty = \"Empty CSV. Please provide something.\",\n      errorEmptyHeader = \"Could not detect header. Ensure first row cotains your column headers.\",\n      separators = [\",\", \";\", \"\\t\"],\n      pegjsSeparatorNames = {\n    \",\": \"comma\",\n    \";\": \"semicolon\",\n    \"\\t\": \"tab\"\n  }; // Picks the separator we find the most.\n\n  function detectSeparator(csv) {\n    var counts = {},\n        sepMax;\n    separators.forEach(function (sep, i) {\n      var re = new RegExp(sep, 'g');\n      counts[sep] = (csv.match(re) || []).length;\n      sepMax = !sepMax || counts[sep] > counts[sepMax] ? sep : sepMax;\n    });\n    return sepMax;\n  } // Source: https://stackoverflow.com/questions/4856717/javascript-equivalent-of-pythons-zip-function\n\n\n  function zip() {\n    var args = [].slice.call(arguments);\n    var longest = args.reduce(function (a, b) {\n      return a.length > b.length ? a : b;\n    }, []);\n    return longest.map(function (_, i) {\n      return args.map(function (array) {\n        return array[i];\n      });\n    });\n  }\n\n  function uniquify(keys) {\n    var counts = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (counts[key] === undefined) {\n        counts[key] = 0;\n      } else {\n        counts[key]++;\n      }\n    }\n\n    var result = [];\n\n    for (var i = keys.length - 1; i >= 0; i--) {\n      var key = keys[i];\n      if (counts[key] > 0) key = key + '__' + counts[key]--;\n      result.unshift(key);\n    }\n\n    return result;\n  }\n\n  function convert(csv, options) {\n    options || (options = {});\n    if (csv.length == 0) throw errorEmpty;\n    var separator = options.separator || detectSeparator(csv);\n    if (!separator) throw errorDetectingSeparator;\n    var a = [];\n\n    try {\n      var a = csvParser.parse(csv, pegjsSeparatorNames[separator]);\n    } catch (error) {\n      var start = csv.lastIndexOf('\\n', error.offset),\n          end = csv.indexOf('\\n', error.offset),\n          line = csv.substring(start >= -1 ? start : 0, end > -1 ? end : csv.length);\n      throw error.message + ' On line ' + error.line + ' and column ' + error.column + '.\\n' + line;\n    }\n\n    if (options.transpose) a = zip.apply(this, a);\n    var keys = a.shift();\n    if (keys.length == 0) throw errorEmptyHeader;\n    keys = keys.map(function (key) {\n      return key.trim().replace(/(^\")|(\"$)/g, '');\n    });\n    keys = uniquify(keys);\n    var json = options.hash ? {} : [];\n\n    for (var l = 0; l < a.length; l++) {\n      var row = {},\n          hashKey;\n\n      for (var i = 0; i < keys.length; i++) {\n        var value = (a[l][i] || '').trim().replace(/(^\")|(\"$)/g, '');\n        var number = value === \"\" ? NaN : value - 0;\n\n        if (options.hash && i == 0) {\n          hashKey = value;\n        } else {\n          if (options.parseJSON || options.parseNumbers && !isNaN(number)) {\n            try {\n              row[keys[i]] = JSON.parse(value);\n            } catch (error) {\n              row[keys[i]] = value;\n            }\n          } else {\n            row[keys[i]] = value;\n          }\n        }\n      }\n\n      if (options.hash) json[hashKey] = row;else json.push(row);\n    }\n\n    return json;\n  }\n\n  ;\n\n  var csvParser = function () {\n    /*\r\n     * Generated by PEG.js 0.7.0.\r\n     *\r\n     * http://pegjs.majda.cz/\r\n     *\r\n     * source: https://gist.github.com/trevordixon/3362830\r\n     * Martin 2018-04-2: Added parse_semicolon function.\r\n     *\r\n     */\n    function quote(s) {\n      /*\r\n       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\r\n       * string literal except for the closing quote character, backslash,\r\n       * carriage return, line separator, paragraph separator, and line feed.\r\n       * Any character may appear in the form of an escape sequence.\r\n       *\r\n       * For portability, we also escape escape all control and non-ASCII\r\n       * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\r\n       * because JSHint does not like the first and IE the second.\r\n       */\n      return '\"' + s.replace(/\\\\/g, '\\\\\\\\') // backslash\n      .replace(/\"/g, '\\\\\"') // closing quote character\n      .replace(/\\x08/g, '\\\\b') // backspace\n      .replace(/\\t/g, '\\\\t') // horizontal tab\n      .replace(/\\n/g, '\\\\n') // line feed\n      .replace(/\\f/g, '\\\\f') // form feed\n      .replace(/\\r/g, '\\\\r') // carriage return\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape) + '\"';\n    }\n\n    var result = {\n      /*\r\n       * Parses the input with a generated parser. If the parsing is successfull,\r\n       * returns a value explicitly or implicitly specified by the grammar from\r\n       * which the parser was generated (see |PEG.buildParser|). If the parsing is\r\n       * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\r\n       */\n      parse: function (input, startRule) {\n        var parseFunctions = {\n          \"comma\": parse_comma,\n          \"semicolon\": parse_semicolon,\n          \"tab\": parse_tab,\n          \"sv\": parse_sv,\n          \"line\": parse_line,\n          \"field\": parse_field,\n          \"char\": parse_char\n        };\n\n        if (startRule !== undefined) {\n          if (parseFunctions[startRule] === undefined) {\n            throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n          }\n        } else {\n          startRule = \"comma\";\n        }\n\n        var pos = 0;\n        var reportFailures = 0;\n        var rightmostFailuresPos = 0;\n        var rightmostFailuresExpected = [];\n\n        function padLeft(input, padding, length) {\n          var result = input;\n          var padLength = length - input.length;\n\n          for (var i = 0; i < padLength; i++) {\n            result = padding + result;\n          }\n\n          return result;\n        }\n\n        function escape(ch) {\n          var charCode = ch.charCodeAt(0);\n          var escapeChar;\n          var length;\n\n          if (charCode <= 0xFF) {\n            escapeChar = 'x';\n            length = 2;\n          } else {\n            escapeChar = 'u';\n            length = 4;\n          }\n\n          return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n        }\n\n        function matchFailed(failure) {\n          if (pos < rightmostFailuresPos) {\n            return;\n          }\n\n          if (pos > rightmostFailuresPos) {\n            rightmostFailuresPos = pos;\n            rightmostFailuresExpected = [];\n          }\n\n          rightmostFailuresExpected.push(failure);\n        }\n\n        function parse_comma() {\n          var result0, result1;\n          var pos0, pos1;\n          pos0 = pos;\n          pos1 = pos;\n          result0 = function (offset) {\n            return separator = ',';\n          }(pos) ? \"\" : null;\n\n          if (result0 !== null) {\n            result1 = parse_sv();\n\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, sv) {\n              return sv;\n            }(pos0, result0[1]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          return result0;\n        }\n\n        function parse_semicolon() {\n          var result0, result1;\n          var pos0, pos1;\n          pos0 = pos;\n          pos1 = pos;\n          result0 = function (offset) {\n            return separator = ';';\n          }(pos) ? \"\" : null;\n\n          if (result0 !== null) {\n            result1 = parse_sv();\n\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, sv) {\n              return sv;\n            }(pos0, result0[1]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          return result0;\n        }\n\n        function parse_tab() {\n          var result0, result1;\n          var pos0, pos1;\n          pos0 = pos;\n          pos1 = pos;\n          result0 = function (offset) {\n            return separator = '\\t';\n          }(pos) ? \"\" : null;\n\n          if (result0 !== null) {\n            result1 = parse_sv();\n\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, sv) {\n              return sv;\n            }(pos0, result0[1]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          return result0;\n        }\n\n        function parse_sv() {\n          var result0, result1, result2, result3, result4;\n          var pos0, pos1, pos2, pos3;\n          pos0 = pos;\n          pos1 = pos;\n          result0 = [];\n\n          if (/^[\\n\\r]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n\n            if (reportFailures === 0) {\n              matchFailed(\"[\\\\n\\\\r]\");\n            }\n          }\n\n          while (result1 !== null) {\n            result0.push(result1);\n\n            if (/^[\\n\\r]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\n\\\\r]\");\n              }\n            }\n          }\n\n          if (result0 !== null) {\n            result1 = parse_line();\n\n            if (result1 !== null) {\n              result2 = [];\n              pos2 = pos;\n              pos3 = pos;\n\n              if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                result4 = input.charAt(pos);\n                pos++;\n              } else {\n                result4 = null;\n\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\n\\\\r]\");\n                }\n              }\n\n              if (result4 !== null) {\n                result3 = [];\n\n                while (result4 !== null) {\n                  result3.push(result4);\n\n                  if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                    result4 = input.charAt(pos);\n                    pos++;\n                  } else {\n                    result4 = null;\n\n                    if (reportFailures === 0) {\n                      matchFailed(\"[\\\\n\\\\r]\");\n                    }\n                  }\n                }\n              } else {\n                result3 = null;\n              }\n\n              if (result3 !== null) {\n                result4 = parse_line();\n\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos3;\n                }\n              } else {\n                result3 = null;\n                pos = pos3;\n              }\n\n              if (result3 !== null) {\n                result3 = function (offset, data) {\n                  return data;\n                }(pos2, result3[1]);\n              }\n\n              if (result3 === null) {\n                pos = pos2;\n              }\n\n              while (result3 !== null) {\n                result2.push(result3);\n                pos2 = pos;\n                pos3 = pos;\n\n                if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                  result4 = input.charAt(pos);\n                  pos++;\n                } else {\n                  result4 = null;\n\n                  if (reportFailures === 0) {\n                    matchFailed(\"[\\\\n\\\\r]\");\n                  }\n                }\n\n                if (result4 !== null) {\n                  result3 = [];\n\n                  while (result4 !== null) {\n                    result3.push(result4);\n\n                    if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                      result4 = input.charAt(pos);\n                      pos++;\n                    } else {\n                      result4 = null;\n\n                      if (reportFailures === 0) {\n                        matchFailed(\"[\\\\n\\\\r]\");\n                      }\n                    }\n                  }\n                } else {\n                  result3 = null;\n                }\n\n                if (result3 !== null) {\n                  result4 = parse_line();\n\n                  if (result4 !== null) {\n                    result3 = [result3, result4];\n                  } else {\n                    result3 = null;\n                    pos = pos3;\n                  }\n                } else {\n                  result3 = null;\n                  pos = pos3;\n                }\n\n                if (result3 !== null) {\n                  result3 = function (offset, data) {\n                    return data;\n                  }(pos2, result3[1]);\n                }\n\n                if (result3 === null) {\n                  pos = pos2;\n                }\n              }\n\n              if (result2 !== null) {\n                result3 = [];\n\n                if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                  result4 = input.charAt(pos);\n                  pos++;\n                } else {\n                  result4 = null;\n\n                  if (reportFailures === 0) {\n                    matchFailed(\"[\\\\n\\\\r]\");\n                  }\n                }\n\n                while (result4 !== null) {\n                  result3.push(result4);\n\n                  if (/^[\\n\\r]/.test(input.charAt(pos))) {\n                    result4 = input.charAt(pos);\n                    pos++;\n                  } else {\n                    result4 = null;\n\n                    if (reportFailures === 0) {\n                      matchFailed(\"[\\\\n\\\\r]\");\n                    }\n                  }\n                }\n\n                if (result3 !== null) {\n                  result0 = [result0, result1, result2, result3];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, first, rest) {\n              rest.unshift(first);\n              return rest;\n            }(pos0, result0[1], result0[2]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          return result0;\n        }\n\n        function parse_line() {\n          var result0, result1, result2, result3, result4;\n          var pos0, pos1, pos2, pos3;\n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_field();\n\n          if (result0 !== null) {\n            result1 = [];\n            pos2 = pos;\n            pos3 = pos;\n\n            if (input.length > pos) {\n              result2 = input.charAt(pos);\n              pos++;\n            } else {\n              result2 = null;\n\n              if (reportFailures === 0) {\n                matchFailed(\"any character\");\n              }\n            }\n\n            if (result2 !== null) {\n              result3 = function (offset, char) {\n                return char == separator;\n              }(pos, result2) ? \"\" : null;\n\n              if (result3 !== null) {\n                result4 = parse_field();\n\n                if (result4 !== null) {\n                  result2 = [result2, result3, result4];\n                } else {\n                  result2 = null;\n                  pos = pos3;\n                }\n              } else {\n                result2 = null;\n                pos = pos3;\n              }\n            } else {\n              result2 = null;\n              pos = pos3;\n            }\n\n            if (result2 !== null) {\n              result2 = function (offset, char, text) {\n                return text;\n              }(pos2, result2[0], result2[2]);\n            }\n\n            if (result2 === null) {\n              pos = pos2;\n            }\n\n            while (result2 !== null) {\n              result1.push(result2);\n              pos2 = pos;\n              pos3 = pos;\n\n              if (input.length > pos) {\n                result2 = input.charAt(pos);\n                pos++;\n              } else {\n                result2 = null;\n\n                if (reportFailures === 0) {\n                  matchFailed(\"any character\");\n                }\n              }\n\n              if (result2 !== null) {\n                result3 = function (offset, char) {\n                  return char == separator;\n                }(pos, result2) ? \"\" : null;\n\n                if (result3 !== null) {\n                  result4 = parse_field();\n\n                  if (result4 !== null) {\n                    result2 = [result2, result3, result4];\n                  } else {\n                    result2 = null;\n                    pos = pos3;\n                  }\n                } else {\n                  result2 = null;\n                  pos = pos3;\n                }\n              } else {\n                result2 = null;\n                pos = pos3;\n              }\n\n              if (result2 !== null) {\n                result2 = function (offset, char, text) {\n                  return text;\n                }(pos2, result2[0], result2[2]);\n              }\n\n              if (result2 === null) {\n                pos = pos2;\n              }\n            }\n\n            if (result1 !== null) {\n              result2 = function (offset, first, rest) {\n                return !!first || rest.length;\n              }(pos, result0, result1) ? \"\" : null;\n\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, first, rest) {\n              rest.unshift(first);\n              return rest;\n            }(pos0, result0[0], result0[1]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          return result0;\n        }\n\n        function parse_field() {\n          var result0, result1, result2;\n          var pos0, pos1, pos2;\n          pos0 = pos;\n          pos1 = pos;\n\n          if (input.charCodeAt(pos) === 34) {\n            result0 = \"\\\"\";\n            pos++;\n          } else {\n            result0 = null;\n\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n\n          if (result0 !== null) {\n            result1 = [];\n            result2 = parse_char();\n\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_char();\n            }\n\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 34) {\n                result2 = \"\\\"\";\n                pos++;\n              } else {\n                result2 = null;\n\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\"\\\"\");\n                }\n              }\n\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset, text) {\n              return text.join('');\n            }(pos0, result0[1]);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          if (result0 === null) {\n            pos0 = pos;\n            result0 = [];\n            pos1 = pos;\n            pos2 = pos;\n\n            if (/^[^\\n\\r]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n\n              if (reportFailures === 0) {\n                matchFailed(\"[^\\\\n\\\\r]\");\n              }\n            }\n\n            if (result1 !== null) {\n              result2 = function (offset, char) {\n                return char != separator;\n              }(pos, result1) ? \"\" : null;\n\n              if (result2 !== null) {\n                result1 = [result1, result2];\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n\n            if (result1 !== null) {\n              result1 = function (offset, char) {\n                return char;\n              }(pos1, result1[0]);\n            }\n\n            if (result1 === null) {\n              pos = pos1;\n            }\n\n            while (result1 !== null) {\n              result0.push(result1);\n              pos1 = pos;\n              pos2 = pos;\n\n              if (/^[^\\n\\r]/.test(input.charAt(pos))) {\n                result1 = input.charAt(pos);\n                pos++;\n              } else {\n                result1 = null;\n\n                if (reportFailures === 0) {\n                  matchFailed(\"[^\\\\n\\\\r]\");\n                }\n              }\n\n              if (result1 !== null) {\n                result2 = function (offset, char) {\n                  return char != separator;\n                }(pos, result1) ? \"\" : null;\n\n                if (result2 !== null) {\n                  result1 = [result1, result2];\n                } else {\n                  result1 = null;\n                  pos = pos2;\n                }\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n\n              if (result1 !== null) {\n                result1 = function (offset, char) {\n                  return char;\n                }(pos1, result1[0]);\n              }\n\n              if (result1 === null) {\n                pos = pos1;\n              }\n            }\n\n            if (result0 !== null) {\n              result0 = function (offset, text) {\n                return text.join('');\n              }(pos0, result0);\n            }\n\n            if (result0 === null) {\n              pos = pos0;\n            }\n          }\n\n          return result0;\n        }\n\n        function parse_char() {\n          var result0, result1;\n          var pos0, pos1;\n          pos0 = pos;\n          pos1 = pos;\n\n          if (input.charCodeAt(pos) === 34) {\n            result0 = \"\\\"\";\n            pos++;\n          } else {\n            result0 = null;\n\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n\n          if (result0 !== null) {\n            if (input.charCodeAt(pos) === 34) {\n              result1 = \"\\\"\";\n              pos++;\n            } else {\n              result1 = null;\n\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"\\\\\\\"\\\"\");\n              }\n            }\n\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n\n          if (result0 !== null) {\n            result0 = function (offset) {\n              return '\"';\n            }(pos0);\n          }\n\n          if (result0 === null) {\n            pos = pos0;\n          }\n\n          if (result0 === null) {\n            if (/^[^\"]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n\n              if (reportFailures === 0) {\n                matchFailed(\"[^\\\"]\");\n              }\n            }\n          }\n\n          return result0;\n        }\n\n        function cleanupExpected(expected) {\n          expected.sort();\n          var lastExpected = null;\n          var cleanExpected = [];\n\n          for (var i = 0; i < expected.length; i++) {\n            if (expected[i] !== lastExpected) {\n              cleanExpected.push(expected[i]);\n              lastExpected = expected[i];\n            }\n          }\n\n          return cleanExpected;\n        }\n\n        function computeErrorPosition() {\n          /*\r\n           * The first idea was to use |String.split| to break the input up to the\r\n           * error position along newlines and derive the line and column from\r\n           * there. However IE's |split| implementation is so broken that it was\r\n           * enough to prevent it.\r\n           */\n          var line = 1;\n          var column = 1;\n          var seenCR = false;\n\n          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n            var ch = input.charAt(i);\n\n            if (ch === \"\\n\") {\n              if (!seenCR) {\n                line++;\n              }\n\n              column = 1;\n              seenCR = false;\n            } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n              line++;\n              column = 1;\n              seenCR = true;\n            } else {\n              column++;\n              seenCR = false;\n            }\n          }\n\n          return {\n            line: line,\n            column: column\n          };\n        }\n\n        var separator = ',';\n        var result = parseFunctions[startRule]();\n        /*\r\n         * The parser is now in one of the following three states:\r\n         *\r\n         * 1. The parser successfully parsed the whole input.\r\n         *\r\n         *    - |result !== null|\r\n         *    - |pos === input.length|\r\n         *    - |rightmostFailuresExpected| may or may not contain something\r\n         *\r\n         * 2. The parser successfully parsed only a part of the input.\r\n         *\r\n         *    - |result !== null|\r\n         *    - |pos < input.length|\r\n         *    - |rightmostFailuresExpected| may or may not contain something\r\n         *\r\n         * 3. The parser did not successfully parse any part of the input.\r\n         *\r\n         *   - |result === null|\r\n         *   - |pos === 0|\r\n         *   - |rightmostFailuresExpected| contains at least one failure\r\n         *\r\n         * All code following this comment (including called functions) must\r\n         * handle these states.\r\n         */\n\n        if (result === null || pos !== input.length) {\n          var offset = Math.max(pos, rightmostFailuresPos);\n          var found = offset < input.length ? input.charAt(offset) : null;\n          var errorPosition = computeErrorPosition();\n          throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);\n        }\n\n        return result;\n      },\n\n      /* Returns the parser source code. */\n      toSource: function () {\n        return this._source;\n      }\n    };\n    /* Thrown when a parser encounters a syntax error. */\n\n    result.SyntaxError = function (expected, found, offset, line, column) {\n      function buildMessage(expected, found) {\n        var expectedHumanized, foundHumanized;\n\n        switch (expected.length) {\n          case 0:\n            expectedHumanized = \"end of input\";\n            break;\n\n          case 1:\n            expectedHumanized = expected[0];\n            break;\n\n          default:\n            expectedHumanized = expected.slice(0, expected.length - 1).join(\", \") + \" or \" + expected[expected.length - 1];\n        }\n\n        foundHumanized = found ? quote(found) : \"end of input\";\n        return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n      }\n\n      this.name = \"SyntaxError\";\n      this.expected = expected;\n      this.found = found;\n      this.message = buildMessage(expected, found);\n      this.offset = offset;\n      this.line = line;\n      this.column = column;\n    };\n\n    result.SyntaxError.prototype = Error.prototype;\n    return result;\n  }(); // CommonJS or Browser\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = convert;\n    }\n\n    exports.csv2json = convert;\n  } else {\n    this.CSVJSON || (this.CSVJSON = {});\n    this.CSVJSON.csv2json = convert;\n  }\n}).call(this);","map":{"version":3,"sources":["C:/Users/rocan/OneDrive/Documents/SummitPrime/frontendDev/node_modules/csvjson-csv2json/csv2json.js"],"names":["errorDetectingSeparator","errorNotWellFormed","errorEmpty","errorEmptyHeader","separators","pegjsSeparatorNames","detectSeparator","csv","counts","sepMax","forEach","sep","i","re","RegExp","match","length","zip","args","slice","call","arguments","longest","reduce","a","b","map","_","array","uniquify","keys","key","undefined","result","unshift","convert","options","separator","csvParser","parse","error","start","lastIndexOf","offset","end","indexOf","line","substring","message","column","transpose","apply","shift","trim","replace","json","hash","l","row","hashKey","value","number","NaN","parseJSON","parseNumbers","isNaN","JSON","push","quote","s","escape","input","startRule","parseFunctions","parse_comma","parse_semicolon","parse_tab","parse_sv","parse_line","parse_field","parse_char","Error","pos","reportFailures","rightmostFailuresPos","rightmostFailuresExpected","padLeft","padding","padLength","ch","charCode","charCodeAt","escapeChar","toString","toUpperCase","matchFailed","failure","result0","result1","pos0","pos1","sv","result2","result3","result4","pos2","pos3","test","charAt","data","first","rest","char","text","join","cleanupExpected","expected","sort","lastExpected","cleanExpected","computeErrorPosition","seenCR","Math","max","found","errorPosition","SyntaxError","toSource","_source","buildMessage","expectedHumanized","foundHumanized","name","prototype","exports","module","csv2json","CSVJSON"],"mappings":"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","sourcesContent":["(function() {\r\n  /**\r\n   *\r\n   * Node:\r\n   * const csv2json = require('./csv2json.js');\r\n   * csv2json(csv, options)\r\n   *\r\n   * Browser:\r\n   * CSVJSON.csv2json(csv, options)\r\n   *\r\n   * Converts CSV to JSON. Returns an object. Use JSON.stringify to convert to a string.\r\n   *\r\n   * Available options:\r\n   *  - separator: Optional. Character which acts as separator. If omitted,\r\n   *               will attempt to detect comma (,), semi-colon (;) or tab (\\t).\r\n   *  - parseNumbers: Optional. Will attempt to convert a value to a number, if possible.\r\n   *  - parseJSON: Optional. Will attempt to convert a value to a valid JSON value if possible.\r\n   *               Detects numbers, null, false, true, [] and {}.\r\n   *  - transpose: Optional. Will pivot the table. Default is false.\r\n   *  - hash: Optional. Will use the first column as a key and return a hash instead of\r\n   *               an array of objects. Default is false.\r\n   *\r\n   * Copyright (c) 2014-2019 Martin Drapeau\r\n   *\r\n   */\r\n\r\n  var errorDetectingSeparator = \"We could not detect the separator.\",\r\n      errorNotWellFormed = \"CSV is not well formed\",\r\n      errorEmpty = \"Empty CSV. Please provide something.\",\r\n      errorEmptyHeader = \"Could not detect header. Ensure first row cotains your column headers.\",\r\n      separators = [\",\", \";\", \"\\t\"],\r\n      pegjsSeparatorNames = {\r\n        \",\": \"comma\",\r\n        \";\": \"semicolon\",\r\n        \"\\t\": \"tab\"\r\n      };\r\n\r\n  // Picks the separator we find the most.\r\n  function detectSeparator(csv) {\r\n    var counts = {},\r\n        sepMax;\r\n    separators.forEach(function(sep, i) {\r\n      var re = new RegExp(sep, 'g');\r\n      counts[sep] = (csv.match(re) || []).length;\r\n      sepMax = !sepMax || counts[sep] > counts[sepMax] ? sep : sepMax;\r\n    });\r\n    return sepMax;\r\n  }\r\n\r\n  // Source: https://stackoverflow.com/questions/4856717/javascript-equivalent-of-pythons-zip-function\r\n  function zip() {\r\n    var args = [].slice.call(arguments);\r\n    var longest = args.reduce(function(a,b) {\r\n      return a.length>b.length ? a : b;\r\n    }, []);\r\n\r\n    return longest.map(function(_,i) {\r\n      return args.map(function(array) {\r\n        return array[i];\r\n      });\r\n    });\r\n  }\r\n\r\n  function uniquify(keys) {\r\n    var counts = {};\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n      if (counts[key] === undefined) {\r\n        counts[key] = 0;\r\n      } else {\r\n        counts[key]++;\r\n      }\r\n    }\r\n\r\n    var result = [];\r\n    for (var i = keys.length-1; i >= 0; i--) {\r\n      var key = keys[i];\r\n      if (counts[key] > 0) key = key + '__' + counts[key]--;\r\n      result.unshift(key);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function convert(csv, options) {\r\n    options || (options = {});\r\n    if (csv.length == 0) throw errorEmpty;\r\n\r\n    var separator = options.separator || detectSeparator(csv);\r\n    if (!separator) throw errorDetectingSeparator;\r\n\r\n    var a = [];\r\n    try {\r\n      var a = csvParser.parse(csv, pegjsSeparatorNames[separator]);\r\n    } catch(error) {\r\n      var start = csv.lastIndexOf('\\n', error.offset),\r\n          end = csv.indexOf('\\n', error.offset),\r\n          line = csv.substring(start >= -1 ? start : 0, end > -1 ? end : csv.length);\r\n      throw error.message + ' On line ' + error.line + ' and column ' + error.column + '.\\n' + line;\r\n    }\r\n\r\n    if (options.transpose) a = zip.apply(this, a);\r\n\r\n    var keys = a.shift();\r\n    if (keys.length == 0) throw errorEmptyHeader;\r\n    keys = keys.map(function(key) {\r\n      return key.trim().replace(/(^\")|(\"$)/g, '');\r\n    });\r\n\r\n    keys = uniquify(keys);\r\n\r\n    var\tjson = options.hash ? {} : [];\r\n    for (var l = 0; l < a.length; l++) {\r\n      var row = {},\r\n      hashKey;\r\n      for (var i = 0; i < keys.length; i++) {\r\n        var value = (a[l][i]||'').trim().replace(/(^\")|(\"$)/g, '');\r\n        var number = value === \"\" ? NaN : value - 0;\r\n        if (options.hash && i == 0) {\r\n          hashKey = value;\r\n        }\r\n        else {\r\n          if (options.parseJSON || options.parseNumbers && !isNaN(number)) {\r\n            try {\r\n              row[keys[i]] = JSON.parse(value);\r\n            } catch(error) {\r\n              row[keys[i]] = value;\r\n            }\r\n          }\r\n          else {\r\n            row[keys[i]] = value;\r\n          }\r\n        }\r\n      }\r\n      if (options.hash)\r\n        json[hashKey] = row;\r\n      else\r\n        json.push(row);\r\n    }\r\n\r\n    return json;\r\n  };\r\n\r\n  var csvParser = (function(){\r\n    /*\r\n     * Generated by PEG.js 0.7.0.\r\n     *\r\n     * http://pegjs.majda.cz/\r\n     *\r\n     * source: https://gist.github.com/trevordixon/3362830\r\n     * Martin 2018-04-2: Added parse_semicolon function.\r\n     *\r\n     */\r\n    \r\n    function quote(s) {\r\n      /*\r\n       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\r\n       * string literal except for the closing quote character, backslash,\r\n       * carriage return, line separator, paragraph separator, and line feed.\r\n       * Any character may appear in the form of an escape sequence.\r\n       *\r\n       * For portability, we also escape escape all control and non-ASCII\r\n       * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\r\n       * because JSHint does not like the first and IE the second.\r\n       */\r\n       return '\"' + s\r\n        .replace(/\\\\/g, '\\\\\\\\')  // backslash\r\n        .replace(/\"/g, '\\\\\"')    // closing quote character\r\n        .replace(/\\x08/g, '\\\\b') // backspace\r\n        .replace(/\\t/g, '\\\\t')   // horizontal tab\r\n        .replace(/\\n/g, '\\\\n')   // line feed\r\n        .replace(/\\f/g, '\\\\f')   // form feed\r\n        .replace(/\\r/g, '\\\\r')   // carriage return\r\n        .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\r\n        + '\"';\r\n    }\r\n    \r\n    var result = {\r\n      /*\r\n       * Parses the input with a generated parser. If the parsing is successfull,\r\n       * returns a value explicitly or implicitly specified by the grammar from\r\n       * which the parser was generated (see |PEG.buildParser|). If the parsing is\r\n       * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\r\n       */\r\n      parse: function(input, startRule) {\r\n        var parseFunctions = {\r\n          \"comma\": parse_comma,\r\n          \"semicolon\": parse_semicolon,\r\n          \"tab\": parse_tab,\r\n          \"sv\": parse_sv,\r\n          \"line\": parse_line,\r\n          \"field\": parse_field,\r\n          \"char\": parse_char\r\n        };\r\n        \r\n        if (startRule !== undefined) {\r\n          if (parseFunctions[startRule] === undefined) {\r\n            throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\r\n          }\r\n        } else {\r\n          startRule = \"comma\";\r\n        }\r\n        \r\n        var pos = 0;\r\n        var reportFailures = 0;\r\n        var rightmostFailuresPos = 0;\r\n        var rightmostFailuresExpected = [];\r\n        \r\n        function padLeft(input, padding, length) {\r\n          var result = input;\r\n          \r\n          var padLength = length - input.length;\r\n          for (var i = 0; i < padLength; i++) {\r\n            result = padding + result;\r\n          }\r\n          \r\n          return result;\r\n        }\r\n        \r\n        function escape(ch) {\r\n          var charCode = ch.charCodeAt(0);\r\n          var escapeChar;\r\n          var length;\r\n          \r\n          if (charCode <= 0xFF) {\r\n            escapeChar = 'x';\r\n            length = 2;\r\n          } else {\r\n            escapeChar = 'u';\r\n            length = 4;\r\n          }\r\n          \r\n          return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\r\n        }\r\n        \r\n        function matchFailed(failure) {\r\n          if (pos < rightmostFailuresPos) {\r\n            return;\r\n          }\r\n          \r\n          if (pos > rightmostFailuresPos) {\r\n            rightmostFailuresPos = pos;\r\n            rightmostFailuresExpected = [];\r\n          }\r\n          \r\n          rightmostFailuresExpected.push(failure);\r\n        }\r\n        \r\n        function parse_comma() {\r\n          var result0, result1;\r\n          var pos0, pos1;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = (function(offset) { return separator = ','; })(pos) ? \"\" : null;\r\n          if (result0 !== null) {\r\n            result1 = parse_sv();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, sv) { return sv; })(pos0, result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_semicolon() {\r\n          var result0, result1;\r\n          var pos0, pos1;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = (function(offset) { return separator = ';'; })(pos) ? \"\" : null;\r\n          if (result0 !== null) {\r\n            result1 = parse_sv();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, sv) { return sv; })(pos0, result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_tab() {\r\n          var result0, result1;\r\n          var pos0, pos1;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = (function(offset) { return separator = '\\t'; })(pos) ? \"\" : null;\r\n          if (result0 !== null) {\r\n            result1 = parse_sv();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, sv) { return sv; })(pos0, result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_sv() {\r\n          var result0, result1, result2, result3, result4;\r\n          var pos0, pos1, pos2, pos3;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = [];\r\n          if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n            result1 = input.charAt(pos);\r\n            pos++;\r\n          } else {\r\n            result1 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"[\\\\n\\\\r]\");\r\n            }\r\n          }\r\n          while (result1 !== null) {\r\n            result0.push(result1);\r\n            if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n              result1 = input.charAt(pos);\r\n              pos++;\r\n            } else {\r\n              result1 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"[\\\\n\\\\r]\");\r\n              }\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = parse_line();\r\n            if (result1 !== null) {\r\n              result2 = [];\r\n              pos2 = pos;\r\n              pos3 = pos;\r\n              if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                result4 = input.charAt(pos);\r\n                pos++;\r\n              } else {\r\n                result4 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"[\\\\n\\\\r]\");\r\n                }\r\n              }\r\n              if (result4 !== null) {\r\n                result3 = [];\r\n                while (result4 !== null) {\r\n                  result3.push(result4);\r\n                  if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                    result4 = input.charAt(pos);\r\n                    pos++;\r\n                  } else {\r\n                    result4 = null;\r\n                    if (reportFailures === 0) {\r\n                      matchFailed(\"[\\\\n\\\\r]\");\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                result3 = null;\r\n              }\r\n              if (result3 !== null) {\r\n                result4 = parse_line();\r\n                if (result4 !== null) {\r\n                  result3 = [result3, result4];\r\n                } else {\r\n                  result3 = null;\r\n                  pos = pos3;\r\n                }\r\n              } else {\r\n                result3 = null;\r\n                pos = pos3;\r\n              }\r\n              if (result3 !== null) {\r\n                result3 = (function(offset, data) { return data; })(pos2, result3[1]);\r\n              }\r\n              if (result3 === null) {\r\n                pos = pos2;\r\n              }\r\n              while (result3 !== null) {\r\n                result2.push(result3);\r\n                pos2 = pos;\r\n                pos3 = pos;\r\n                if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                  result4 = input.charAt(pos);\r\n                  pos++;\r\n                } else {\r\n                  result4 = null;\r\n                  if (reportFailures === 0) {\r\n                    matchFailed(\"[\\\\n\\\\r]\");\r\n                  }\r\n                }\r\n                if (result4 !== null) {\r\n                  result3 = [];\r\n                  while (result4 !== null) {\r\n                    result3.push(result4);\r\n                    if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                      result4 = input.charAt(pos);\r\n                      pos++;\r\n                    } else {\r\n                      result4 = null;\r\n                      if (reportFailures === 0) {\r\n                        matchFailed(\"[\\\\n\\\\r]\");\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  result3 = null;\r\n                }\r\n                if (result3 !== null) {\r\n                  result4 = parse_line();\r\n                  if (result4 !== null) {\r\n                    result3 = [result3, result4];\r\n                  } else {\r\n                    result3 = null;\r\n                    pos = pos3;\r\n                  }\r\n                } else {\r\n                  result3 = null;\r\n                  pos = pos3;\r\n                }\r\n                if (result3 !== null) {\r\n                  result3 = (function(offset, data) { return data; })(pos2, result3[1]);\r\n                }\r\n                if (result3 === null) {\r\n                  pos = pos2;\r\n                }\r\n              }\r\n              if (result2 !== null) {\r\n                result3 = [];\r\n                if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                  result4 = input.charAt(pos);\r\n                  pos++;\r\n                } else {\r\n                  result4 = null;\r\n                  if (reportFailures === 0) {\r\n                    matchFailed(\"[\\\\n\\\\r]\");\r\n                  }\r\n                }\r\n                while (result4 !== null) {\r\n                  result3.push(result4);\r\n                  if (/^[\\n\\r]/.test(input.charAt(pos))) {\r\n                    result4 = input.charAt(pos);\r\n                    pos++;\r\n                  } else {\r\n                    result4 = null;\r\n                    if (reportFailures === 0) {\r\n                      matchFailed(\"[\\\\n\\\\r]\");\r\n                    }\r\n                  }\r\n                }\r\n                if (result3 !== null) {\r\n                  result0 = [result0, result1, result2, result3];\r\n                } else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, first, rest) { rest.unshift(first); return rest; })(pos0, result0[1], result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_line() {\r\n          var result0, result1, result2, result3, result4;\r\n          var pos0, pos1, pos2, pos3;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_field();\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            pos2 = pos;\r\n            pos3 = pos;\r\n            if (input.length > pos) {\r\n              result2 = input.charAt(pos);\r\n              pos++;\r\n            } else {\r\n              result2 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"any character\");\r\n              }\r\n            }\r\n            if (result2 !== null) {\r\n              result3 = (function(offset, char) { return char == separator; })(pos, result2) ? \"\" : null;\r\n              if (result3 !== null) {\r\n                result4 = parse_field();\r\n                if (result4 !== null) {\r\n                  result2 = [result2, result3, result4];\r\n                } else {\r\n                  result2 = null;\r\n                  pos = pos3;\r\n                }\r\n              } else {\r\n                result2 = null;\r\n                pos = pos3;\r\n              }\r\n            } else {\r\n              result2 = null;\r\n              pos = pos3;\r\n            }\r\n            if (result2 !== null) {\r\n              result2 = (function(offset, char, text) { return text; })(pos2, result2[0], result2[2]);\r\n            }\r\n            if (result2 === null) {\r\n              pos = pos2;\r\n            }\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              pos2 = pos;\r\n              pos3 = pos;\r\n              if (input.length > pos) {\r\n                result2 = input.charAt(pos);\r\n                pos++;\r\n              } else {\r\n                result2 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"any character\");\r\n                }\r\n              }\r\n              if (result2 !== null) {\r\n                result3 = (function(offset, char) { return char == separator; })(pos, result2) ? \"\" : null;\r\n                if (result3 !== null) {\r\n                  result4 = parse_field();\r\n                  if (result4 !== null) {\r\n                    result2 = [result2, result3, result4];\r\n                  } else {\r\n                    result2 = null;\r\n                    pos = pos3;\r\n                  }\r\n                } else {\r\n                  result2 = null;\r\n                  pos = pos3;\r\n                }\r\n              } else {\r\n                result2 = null;\r\n                pos = pos3;\r\n              }\r\n              if (result2 !== null) {\r\n                result2 = (function(offset, char, text) { return text; })(pos2, result2[0], result2[2]);\r\n              }\r\n              if (result2 === null) {\r\n                pos = pos2;\r\n              }\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = (function(offset, first, rest) { return !!first || rest.length; })(pos, result0, result1) ? \"\" : null;\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, first, rest) { rest.unshift(first); return rest; })(pos0, result0[0], result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_field() {\r\n          var result0, result1, result2;\r\n          var pos0, pos1, pos2;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 34) {\r\n            result0 = \"\\\"\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_char();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_char();\r\n            }\r\n            if (result1 !== null) {\r\n              if (input.charCodeAt(pos) === 34) {\r\n                result2 = \"\\\"\";\r\n                pos++;\r\n              } else {\r\n                result2 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"\\\"\\\\\\\"\\\"\");\r\n                }\r\n              }\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, text) { return text.join(''); })(pos0, result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          if (result0 === null) {\r\n            pos0 = pos;\r\n            result0 = [];\r\n            pos1 = pos;\r\n            pos2 = pos;\r\n            if (/^[^\\n\\r]/.test(input.charAt(pos))) {\r\n              result1 = input.charAt(pos);\r\n              pos++;\r\n            } else {\r\n              result1 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"[^\\\\n\\\\r]\");\r\n              }\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = (function(offset, char) { return char != separator; })(pos, result1) ? \"\" : null;\r\n              if (result2 !== null) {\r\n                result1 = [result1, result2];\r\n              } else {\r\n                result1 = null;\r\n                pos = pos2;\r\n              }\r\n            } else {\r\n              result1 = null;\r\n              pos = pos2;\r\n            }\r\n            if (result1 !== null) {\r\n              result1 = (function(offset, char) { return char; })(pos1, result1[0]);\r\n            }\r\n            if (result1 === null) {\r\n              pos = pos1;\r\n            }\r\n            while (result1 !== null) {\r\n              result0.push(result1);\r\n              pos1 = pos;\r\n              pos2 = pos;\r\n              if (/^[^\\n\\r]/.test(input.charAt(pos))) {\r\n                result1 = input.charAt(pos);\r\n                pos++;\r\n              } else {\r\n                result1 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"[^\\\\n\\\\r]\");\r\n                }\r\n              }\r\n              if (result1 !== null) {\r\n                result2 = (function(offset, char) { return char != separator; })(pos, result1) ? \"\" : null;\r\n                if (result2 !== null) {\r\n                  result1 = [result1, result2];\r\n                } else {\r\n                  result1 = null;\r\n                  pos = pos2;\r\n                }\r\n              } else {\r\n                result1 = null;\r\n                pos = pos2;\r\n              }\r\n              if (result1 !== null) {\r\n                result1 = (function(offset, char) { return char; })(pos1, result1[0]);\r\n              }\r\n              if (result1 === null) {\r\n                pos = pos1;\r\n              }\r\n            }\r\n            if (result0 !== null) {\r\n              result0 = (function(offset, text) { return text.join(''); })(pos0, result0);\r\n            }\r\n            if (result0 === null) {\r\n              pos = pos0;\r\n            }\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        function parse_char() {\r\n          var result0, result1;\r\n          var pos0, pos1;\r\n          \r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 34) {\r\n            result0 = \"\\\"\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            if (input.charCodeAt(pos) === 34) {\r\n              result1 = \"\\\"\";\r\n              pos++;\r\n            } else {\r\n              result1 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"\\\"\\\\\\\"\\\"\");\r\n              }\r\n            }\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset) { return '\"'; })(pos0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n          if (result0 === null) {\r\n            if (/^[^\"]/.test(input.charAt(pos))) {\r\n              result0 = input.charAt(pos);\r\n              pos++;\r\n            } else {\r\n              result0 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"[^\\\"]\");\r\n              }\r\n            }\r\n          }\r\n          return result0;\r\n        }\r\n        \r\n        \r\n        function cleanupExpected(expected) {\r\n          expected.sort();\r\n          \r\n          var lastExpected = null;\r\n          var cleanExpected = [];\r\n          for (var i = 0; i < expected.length; i++) {\r\n            if (expected[i] !== lastExpected) {\r\n              cleanExpected.push(expected[i]);\r\n              lastExpected = expected[i];\r\n            }\r\n          }\r\n          return cleanExpected;\r\n        }\r\n        \r\n        function computeErrorPosition() {\r\n          /*\r\n           * The first idea was to use |String.split| to break the input up to the\r\n           * error position along newlines and derive the line and column from\r\n           * there. However IE's |split| implementation is so broken that it was\r\n           * enough to prevent it.\r\n           */\r\n          \r\n          var line = 1;\r\n          var column = 1;\r\n          var seenCR = false;\r\n          \r\n          for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\r\n            var ch = input.charAt(i);\r\n            if (ch === \"\\n\") {\r\n              if (!seenCR) { line++; }\r\n              column = 1;\r\n              seenCR = false;\r\n            } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\r\n              line++;\r\n              column = 1;\r\n              seenCR = true;\r\n            } else {\r\n              column++;\r\n              seenCR = false;\r\n            }\r\n          }\r\n          \r\n          return { line: line, column: column };\r\n        }\r\n        \r\n        \r\n          var separator = ',';\r\n        \r\n        \r\n        var result = parseFunctions[startRule]();\r\n        \r\n        /*\r\n         * The parser is now in one of the following three states:\r\n         *\r\n         * 1. The parser successfully parsed the whole input.\r\n         *\r\n         *    - |result !== null|\r\n         *    - |pos === input.length|\r\n         *    - |rightmostFailuresExpected| may or may not contain something\r\n         *\r\n         * 2. The parser successfully parsed only a part of the input.\r\n         *\r\n         *    - |result !== null|\r\n         *    - |pos < input.length|\r\n         *    - |rightmostFailuresExpected| may or may not contain something\r\n         *\r\n         * 3. The parser did not successfully parse any part of the input.\r\n         *\r\n         *   - |result === null|\r\n         *   - |pos === 0|\r\n         *   - |rightmostFailuresExpected| contains at least one failure\r\n         *\r\n         * All code following this comment (including called functions) must\r\n         * handle these states.\r\n         */\r\n        if (result === null || pos !== input.length) {\r\n          var offset = Math.max(pos, rightmostFailuresPos);\r\n          var found = offset < input.length ? input.charAt(offset) : null;\r\n          var errorPosition = computeErrorPosition();\r\n          \r\n          throw new this.SyntaxError(\r\n            cleanupExpected(rightmostFailuresExpected),\r\n            found,\r\n            offset,\r\n            errorPosition.line,\r\n            errorPosition.column\r\n          );\r\n        }\r\n        \r\n        return result;\r\n      },\r\n      \r\n      /* Returns the parser source code. */\r\n      toSource: function() { return this._source; }\r\n    };\r\n    \r\n    /* Thrown when a parser encounters a syntax error. */\r\n    \r\n    result.SyntaxError = function(expected, found, offset, line, column) {\r\n      function buildMessage(expected, found) {\r\n        var expectedHumanized, foundHumanized;\r\n        \r\n        switch (expected.length) {\r\n          case 0:\r\n            expectedHumanized = \"end of input\";\r\n            break;\r\n          case 1:\r\n            expectedHumanized = expected[0];\r\n            break;\r\n          default:\r\n            expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\r\n              + \" or \"\r\n              + expected[expected.length - 1];\r\n        }\r\n        \r\n        foundHumanized = found ? quote(found) : \"end of input\";\r\n        \r\n        return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\r\n      }\r\n      \r\n      this.name = \"SyntaxError\";\r\n      this.expected = expected;\r\n      this.found = found;\r\n      this.message = buildMessage(expected, found);\r\n      this.offset = offset;\r\n      this.line = line;\r\n      this.column = column;\r\n    };\r\n    \r\n    result.SyntaxError.prototype = Error.prototype;\r\n    \r\n    return result;\r\n  })();\r\n\r\n\r\n  // CommonJS or Browser\r\n  if (typeof exports !== 'undefined') {\r\n      if (typeof module !== 'undefined' && module.exports) {\r\n          exports = module.exports = convert;\r\n      }\r\n      exports.csv2json = convert;\r\n  } else {\r\n    this.CSVJSON || (this.CSVJSON = {});\r\n    this.CSVJSON.csv2json = convert;\r\n  }\r\n\r\n}).call(this);"]},"metadata":{},"sourceType":"script"}